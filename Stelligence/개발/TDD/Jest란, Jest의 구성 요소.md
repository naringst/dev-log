# Jest란

## 간단 설명
- Jest는 JavaScript를 위한 인기 있는 테스팅 프레임워크. 
- Facebook에 의해 개발되었으며, React 애플리케이션을 비롯한 모든 JavaScript 애플리케이션의 유닛 테스트(Unit Tests), 통합 테스트(Integration Tests), 그리고 UI 테스트를 위해 널리 사용
- Jest는 그 자체로 매우 포괄적인 테스팅 솔루션을 제공하기 때문에, 추가적인 툴 없이도 많은 테스팅 작업을 처리 가능

## 핵심 내용
- **간편한 설정**: Jest는 설정이 간편하며, 대부분의 경우 별도의 설정 없이 바로 사용할 수 있습니다. React 프로젝트의 경우, `create-react-app`을 사용하면 Jest가 기본적으로 포함되어 있습니다.
    
- **제로 설정(Zero Configuration)**: Jest는 제로 설정으로 작동하도록 설계되었습니다. 이는 개발자가 복잡한 설정을 할 필요 없이 테스트를 바로 시작할 수 있음을 의미합니다.
    
- **스냅샷 테스팅**: Jest는 UI 컴포넌트의 렌더링 결과를 스냅샷으로 저장하고, 이후 테스트 실행 시 저장된 스냅샷과 비교함으로써 UI 변경 사항을 쉽게 감지할 수 있는 스냅샷 테스팅을 지원합니다.
    
- **모의 함수(Mock Functions)**: Jest는 모의 함수(mock functions)를 제공하여, 함수 호출, 반환 값, 인스턴스화 및 함수 호출 시 전달된 매개변수를 추적할 수 있습니다. 이는 의존성을 가진 모듈을 테스트할 때 유용합니다.
    
- **동시성 실행**: Jest는 테스트 케이스를 병렬로 실행하여 테스트 성능을 향상시킵니다. 이는 큰 프로젝트에서 테스트 실행 시간을 단축시키는 데 도움이 됩니다.
    
- **코드 커버리지**: Jest는 코드 커버리지 리포트를 자동으로 생성하는 기능을 내장하고 있습니다. 이는 테스트가 프로젝트의 어느 부분을 커버하는지 쉽게 파악할 수 있게 해줍니다.
    

## 구성요소
## describe

```javascript
		describe('토론 목록 페이지 테스트', () => {
		  test('토론 정렬', () => {
	   
		  });
		  test('토론 페이지네이션', () => {
	   
		  });
		});
```

## it(test)
- **test**: 테스트 케이스를 정의합니다. 첫 번째 인자로 테스트 케이스의 설명을, 두 번째 인자로 테스트를 실행할 함수를 받습니다.
- 예시
	```javascript
	test('토론 정렬', () => {
		//특정 페이지 렌더링
		//페이지의 요소 가져오기
		// 요소가 특정 조건을 만족하는지 확인
	  expect(true).toBe(true);	
	});
	```
- 각각의 test => 개별 test 로직
그 안에서 render, fire, matcher 등등 사용

### test 내에서 쓰는 함수들
####  render 함수
- DOM에 컴포넌트를 렌더링 하는 함수.
- 인자로 렌더링할 React 컴포넌트가 들어감.
- render(<Page />);

#### 쿼리 함수
- 특정 DOM 요소를 찾기 위해 쓰는 함수
- `getByText`, `getByRole`, `getByTestId`
- 보통 getByRole을 많이 사용 -> getByRole하면 해당 객체에 focus가 된다.
	- getByRole을 사용하는 구체적인 이유
		`getByRole`은 React Testing Library와 같은 테스트 유틸리티에서 제공하는 쿼리 중 하나로, 웹 접근성(Accessibility) 표준을 기반으로 요소를 찾는 데 사용됩니다. `getByRole`을 사용하는 주된 이유는 다음과 같습니다:
		1. 접근성 강화
		- `getByRole`은 요소의 ARIA 역할(roles)을 기반으로 검색합니다. ARIA 역할은 웹 콘텐츠의 접근성을 높이는 데 중요한 역할을 하며, 스크린 리더와 같은 보조 기술이 콘텐츠를 이해하는 데 도움을 줍니다.
		- 이 방법을 사용함으로써 개발자는 자연스럽게 접근성이 높은 웹 애플리케이션을 구축하도록 유도되며, 테스트 코드 역시 접근성 기준을 충족하는 요소에 대해 작성됩니다.
		
		2. 더 견고한 테스트
		- `getByRole`로 요소를 선택하는 것은 특정 요소의 역할에 초점을 맞추기 때문에, 클래스 이름, 태그 이름, 텍스트 콘텐츠 등의 변화에 비해 덜 취약합니다.
		- 예를 들어, 디자인 변경으로 인한 클래스 이름의 변경이나 텍스트 라벨의 수정이 테스트에 영향을 미치지 않도록 할 수 있습니다.
		- 이러한 방식으로 테스트를 작성하면, UI의 변화에 더욱 유연하게 대응할 수 있으며, 애플리케이션의 실제 기능과 사용자의 인터랙션 방식을 더 정확하게 반영할 수 있습니다.
		
		3. 사용자 중심의 테스트
		- `getByRole`을 사용하면, 개발자는 코드를 작성할 때 사용자가 인터페이스와 어떻게 상호작용하는지를 고려하게 됩니다. 즉, 테스트가 실제 사용자의 경험을 더 잘 반영하도록 유도합니다.
		- 사용자의 관점에서 중요한 요소를 식별하고, 그 요소들이 올바르게 작동하는지를 검증함으로써, 사용자 경험의 질을 향상시킬 수 있습니다.
		
		 4. 일관된 쿼리 우선순위
		- React Testing Library는 테스팅을 위한 쿼리 방법에 우선순위를 제공합니다. 이 가이드라인에 따르면, 가능하면 ARIA 역할을 가진 요소를 쿼리하는 것이 우선시됩니다.
		- 이러한 접근 방식은 테스트가 보다 예측 가능하고, 일관되며, 실제 사용자의 인터랙션을 더 잘 반영하도록 합니다.


- const item = await screen.findByText('dfs는 이렇게 구현하면 안됩니다'); 
	- 보통 위와 같이 스크린 객체에 다음 내용이 있는지를 쿼리 함수로 찾는다.
- ![[스크린샷 2024-02-02 오후 3.26.01.png]]

#### fireEvent
- 유저가 발생시키는 액션(이벤트)에 대한 테스트를 해야 하는 경우 사용
- fireEvent.click(buttonElement) 이런 식으로 활용
- 하지만 userEvent를 사용하는 것이 더 좋다.(강의 참고)

#### expect 함수
테스트 대상의 값이 예상과 일치하는지 검사하는 함수입니다. 다양한 "매처" 함수와 함께 사용
```javascript
expect(value).toBe(expectedValue);
```
#### matcher 함수
테스트하고자 하는 값이 예상하는 조건이나 값과 일치하는지 검증하는 데 사용
 - **toBe**: 정확한 값 비교에 사용됩니다.
-  **toEqual**: 객체나 배열 같은 복합 데이터 타입을 재귀적으로 검사할 때 사용됩니다.
-  **toContain**: 배열이 특정 항목을 포함하는지 확인합니다.
- **toMatch**: 문자열이 정규 표현식과 매치되는지 확인합니다.


## beforeEach/afterEach
- **`beforeEach`**: 각 테스트 케이스가 실행되기 전에 호출됩니다. 테스트에서 공통적으로 필요한 사전 설정 작업을 수행하기에 적합합니다. 예를 들어, 테스트에서 사용할 데이터를 초기화하거나 DOM 요소를 생성하는 등의 작업을 할 수 있습니다.
    
- **`afterEach`**: 각 테스트 케이스가 실행된 후에 호출됩니다. 주로 `beforeEach`에서 수행한 작업에 대한 클린업을 수행합니다. 예를 들어, 생성한 DOM 요소를 제거하거나 모킹한 함수를 초기화하는 등의 작업을 할 수 있습니다.

### beforeAll/afterAll
- 전체 테스트 파일에 대해 처음/마지막에 한 번씩만 실행될 함수를 정의합니다.
-  **`beforeAll`**: 전체 테스트 모듈이 실행되기 전에 딱 한 번만 호출됩니다. 모든 테스트 케이스에 공통적으로 적용되어야 할 사전 설정이 있을 때 사용합니다. 예를 들어, 테스트에 필요한 외부 리소스를 불러오거나, 테스트 모듈 전체에서 사용할 변수를 초기화하는 등의 작업에 적합합니다.
    
- **`afterAll`**: 전체 테스트 모듈의 실행이 끝난 후에 딱 한 번만 호출됩니다. `beforeAll`에서 수행한 사전 설정에 대한 정리 작업을 수행합니다. 예를 들어, 사용한 외부 리소스를 해제하거나, 전체 테스트에서 생성한 임시 파일을 삭제하는 등의 작업을 할 수 있습니다.



### Axios Mocking
- Jest mock 
	- jest.fn()
	- jest.mock()

Axios 호출을 모킹하려면, `jest.mock()` 함수를 사용하거나 `axios-mock-adapter`, `nock` 등의 라이브러리를 사용할 수 있습니다. 여기서는 `jest.mock()`을 사용하는 방법을 간략히 설명하겠습니다.
- axios 모듈을 mock하면, get 메소드에 대해 mockResolvedValue를 제공하며 테스트에 사용될 데이터를 리턴할 수 있다.


1. **Axios 모킹**: `jest.mock()`을 사용하여 Axios 모듈을 모킹합니다.
	```javascript
    jest.mock('axios');
    ```
    
2. **응답 설정**: Axios의 메소드(예: `get`, `post`)에 대해 모킹 함수를 설정하고, 특정 응답을 반환하도록 구성합니다.
    
	```javascript
    import axios from 'axios';  
    axios.get.mockResolvedValue({ data: 'some data' });
    ```
    
3. **테스트 실행**: Axios 호출을 포함하는 함수를 테스트하고, 올바른 결과가 반환되는지 확인합니다.
    
```javascript 
test('should fetch data', async () => {   
	const result = await fetchData(); // fetchData 내부에서 axios.get을 호출 
	  expect(result).toEqual('some data'); 
	});

```

이 방식을 사용하면, 실제 HTTP 요청을 보내지 않고도 Axios 요청을 테스트할 수 있습니다. 이는 테스트의 속도를 높이고, 외부 서비스의 가용성에 의존하지 않게 만들어 줍니다.



